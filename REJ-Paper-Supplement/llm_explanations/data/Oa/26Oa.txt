**Original LTL formula**

\[
\boxed{\, X\,t \;\Rightarrow\; X\,y \,}
\]

---

### 1. Parsing tree (bottom‑up)

```
          (→)
         /   \
    (X)       (X)
     |         |
     t         y
```

* **Root** – implication `→`
* **Left child** – unary ‘next’ `X` applied to atomic `t`
* **Right child** – unary ‘next’ `X` applied to atomic `y`

---

### 2. Rebuilding the meaning from the leaves up

1. **Atomic propositions**  
   * `t` = “property *t* holds in the current state”  
   * `y` = “property *y* holds in the current state”

2. **Unary ‘next’ operator**  
   * `X t` = “in the **next** state, *t* holds”  
   * `X y` = “in the **next** state, *y* holds”

3. **Implication**  
   * `X t → X y` at a given state *i* reads:  
     “If the next state (*i+1*) satisfies *t*, **then** that same next state (*i+1*) also satisfies *y*.”

4. **Temporal shift**  
   Because the implication is evaluated in the **current** state, the “next” part shifts the relation one step forward.  
   For every state index *i* (except the very first one, which has no predecessor):

   \[
   \text{If } t\text{ is true at state }i+1,\text{ then } y\text{ is also true at state }i+1.
   \]

   In other words:  
   *From the second step onward, whenever `t` becomes true, `y` must be true at the same instant.*

---

### 3. Refined natural‑language description

> **“For all steps of the execution that are not the very first state,**  
> **if the system enters a state where property `t` holds, *y* must also hold in that same state.”**

Or equivalently:

> **“On every state after the initial one, `t` can never be true without `y` also being true.”**

---

### 4. What the formula enforces in a system

* **Constraint** – `t` cannot “survive” without `y`.  
* **Locality** – The requirement is only about the immediate next state; nothing is stated about earlier or later states beyond that single step.
* **Effect on transitions** – From any state *s*, if a transition leads to a successor state **s′** where `t` holds, that successor state must also have `y`.

So, in practical terms, if the system ever reaches a situation where `t` becomes true, the designer guarantees that `y` will be true at the very same moment (one step ahead). This is a simple but powerful way to couple two properties in a temporal specification.